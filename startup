--[[
	Vars
		Slot 1 = Logs
		Slot 2 = Dirt
        Slot 3 = Saplings
        Slot 4 = Cobblestone
        Slot 5 = Coal
--]]
VER = 0.2;
NORTH, EAST, SOUTH, WEST = 0, 1, 2, 3;

LOG, DIRT, SAPLING, COBBLE, COAL = 1, 2, 3, 4, 5;

----------------------------------------------------------------------
-- Tasks
----------------------------------------------------------------------

--[[
	First Task:
		find first adjacent tree
--]]
function findFirstTree()
	clearInventory();
	turtle.select(LOG);
	while true do
		-- Get first wood
		if turtle.detect() then
			turtle.dig();
			
			-- Check is wood
			if turtle.refuel() then
				-- Get second wood
				turtle.forward();
				turtle.up();
				
				-- Get rest of the wood
				while turtle.compareUp() do turtle.up(); end
				
				-- Save 1 wood
				turtle.placeDown();
				
				-- Refuel with sticks
				turtle.craft();
				turtle.transferTo(5, turtle.getItemCount(1) / 2);
				turtle.craft();
				turtle.refuel(true, 64);
				
				-- Get back 1 wood
				turtle.digDown();
				
				-- Goto start hight but here
				turtle.goto(state.x, 0, state.z);
				
				-- Get dirt
				turtle.select(2);
				turtle.digDown();
				
				-- Move home location
				state.home.x = state.x;
				state.home.y = 2;
				state.home.z = state.z;
				
				-- Next job
				turtle.setJob(findMoreTrees);
				break;
			else
				turtle.drop();
			end
		else
			turtle.turnLeft();
		end
	end
end

--[[
    Second Task:
		find more near by trees
--]]
function findMoreTrees()
	turtle.goHome();
	
	removeUnwanted(3);
	turtle.select(1);
	
	local oldSlots = { [1] = turtle.getItemCount(1), [2] = turtle.getItemCount(2) };
	
	-- loop
	for sideLng = 1, 10 do
		for corners = 0, 1 do
			for xz = 1, sideLng do
				turtle.forward();
				
				if turtle.getItemCount(1) > oldSlots[1] then
					oldSlots[1] = turtle.getItemCount(1);
					cutTree(1, 3);
				elseif turtle.getItemCount(2) > oldSlots[2] then
					oldSlots[2] = turtle.getItemCount(2);
					if (state.y < state.home.y + 4) then 
						turtle.up();
					end
				elseif turtle.getItemCount(3) > 0 then                
					-- Check is an unknown tree, if is cut it down using it all as fuel
					turtle.select(3);
					if (turtle.compareUp() or turtle.compareDown()) and turtle.refuel(true) then
						cutTree(3, 4);
					-- Only avoid if not too high already
					elseif (state.y < state.home.y + 4) then
					    turtle.up();
					end
					
					turtle.clearSlot(3);
					turtle.select(1);
				end
			end
			turtle.turnRight();
		end
	end
	
	removeUnwanted(3);
	
	turtle.setJob(findSaplings);
end

--[[
	Third Task:
		collect sapplings from first tree
--]]
function findSaplings()
    turtle.select(1);
    turtle.goto(state.home.x + NORTH, 0, state.home.z);
    turtle.face(NORTH);
    
    -- Remove any unwanted items from going home
    turtle.removeUnwanted(3);
    turtle.select(SAPLING);
    
    local found = false;
    for side=1, 4 do
        for face=1, 4 do
            turtle.turnRight();
            turtle.suck();
            
            if not found then
                -- if can't place not a sapling
                if not turtle.placeUp() then
                    turtle.transferTo(11);
                else
                    turtle.breakUp();
                    found = true;
                end
            end
        end
        turtle.turnRight();
        turtle.forward();
        
        -- On all but first side go forward twice
        if side ~= 1 then 
            turtle.forward();
        end
    end
    
    turtle.setJob(getCobblestone);
end

--[[
	Fourth Task:
		find cobblestone
--]]
function getCobblestone()
    -- Get any saplings that fell in dirt hole
    turtle.goto(state.home.x, 0, state.home.z);
    turtle.suckDown();
    
    turtle.removeUnwanted(4);
    turtle.select(4);
    
    while turtle.digDown() do
        turtle.down();
    end
    
    -- Hit bottom, save height
    state.home.y = state.y;
    state.y = 0;
    
    -- Dig to top
    turtle.forward();
    turtle.goto(state.x, state.home.y, state.z);
    
    -- Break surface if needed
    while turtle.detectUp() do turtle.up(); end
    
    -- Cobble must be one of first new blocks broken
    local highSlot, highSlotCount = 4, turtle.getItemCount(highSlot);
    for slot = 5, 10 do
        if turtle.getItemCount(slot) > highSlotCount then
            highSlot = slot;
        end
    end
    
    -- Move cobblestone if needed
    if highSlot ~= 4 then
        storeItem(4, 16);
        
        turtle.select(highSlot);
        turtle.transfterTo(4);
    end
    
    turtle.setJob(findCoal);
end

--[[
    Fifth Task:
        using items from find cobblestone determine which is coal
--]]
function findCoal()    
    -- Clear a space for placing
    turtle.digUp();
    
    for i=5, 16 do
        turtle.select(i);
        
        -- If can be placed not coal
        if turtle.placeUp() then
            turtle.digUp();
        -- If can't be placed and can refuel is coal
        elseif turtle.refuel(true, 1) then
            if i ~= 5 then
            	storeItem(5, 12);
            	turtle.transferTo(5);
            end
            break;
        end
    end

    turtle.setJob(buildBase);
end

--[[
    Task:
        build a base
--]]
function buildBase()
    -- Finalize home
    state.home.y = state.home.y + 11;
    turtle.goto(state.home.x, state.home.y - 1, state.home.z);
    
    turtle.select(4);
    turtle.face(NORTH);
    

    turtle.setJob(digIron);
end

--[[
    Task:
        go underground and mine a section looking for iron
--]]
function digIron()
    turtle.select(1);
    turtle.forward();
    
    -- Ore commong from (30-40)
    turtle.goto(state.x, 35, state.z);
    
    turtle.setJob(nil);
end

----------------------------------------------------------------------
-- Util
----------------------------------------------------------------------

--[[
	Common Functions
--]]

-- Cut down a tree and remove excess in overflow slot
function cutTree(pTargSlot, pOverflow)
	assert(type(pOverflow) == "number" and type(pTargSlot) == "number", "Slots must be numbers");

	local startY = state.y;
	
	turtle.select(pTargSlot);
	while turtle.compareUp() do turtle.up(); end
	
	turtle.goto(state.x, startY, state.z);
	
	while turtle.compareDown() do turtle.down(); end
	
	turtle.goto(state.x, startY, state.z);
	
	turtle.clearSlot(pOverflow);
end

function storeItem(pOldSlot, pNewSlot)
    turtle.select(pOldSlot);
    turtle.transferTo(pNewSlot);
end

--[[
	New Turtle Util
--]]
oldTurtle = {
	turnRight = turtle.turnRight, turnLeft = turtle.turnLeft,
	forward = turtle.forward, back = turtle.back,
	up = turtle.up, down = turtle.down,
	refuel = turtle.refuel
};

turtle.setJob = function(pJob)
	assert(pJob == nil or type(pJob) == "function");
	
	state.prevJob = state.job;
	state.job = pJob;
end

turtle.refuel = function(pForce, pAmount)	
	if pForce or turtle.getFuelLevel() < 1 then
		if pAmount == nil then pAmount = 64; end
	
		return oldTurtle.refuel(pAmount);
	else
		return true;
	end
end

-- Slow, use sparingly
turtle.back = function()
	turtle.turnRight();
	turtle.turnRight();
	if turtle.forward() then
		turtle.turnLeft();
		turtle.turnLeft();
	
		return true;
	else
		return false;
	end
end

turtle.forward = function()
	turtle.refuel();

	while not oldTurtle.forward() do
		-- Try to mine, if can't mine hit something unmineable (bedrock)
		if turtle.detect() and not turtle.dig() then return false; end
	
		while turtle.attack() do end
	end
	
	if state.face == NORTH then state.x = state.x + 1;
	elseif state.face == SOUTH then state.x = state.x - 1;
	elseif state.face == EAST then state.z = state.z + 1;
	elseif state.face == WEST then state.z = state.z - 1;
	else error("Turtle invalid face " .. state.face);
	end
	
	return true;
end
	
turtle.up = function()
	turtle.refuel();

	while not oldTurtle.up() do
		-- Try to mine, if can't mine hit something unmineable (bedrock)
		if turtle.detectUp() and not turtle.digUp() then return false; end
		
		while turtle.attackUp() do end
	end
	
	state.y = state.y + 1;
	return true;
end

turtle.down = function()
	turtle.refuel();

	while not oldTurtle.down() do
		-- Try to mine, if can't mine hit something unmineable (bedrock)
		if turtle.detectDown() and not turtle.digDown() then return false; end
		
		while turtle.attackDown() do end
	end

	state.y = state.y - 1;
	return true;
end

turtle.turnRight = function()
	oldTurtle.turnRight();
	state.face = (state.face + 1) % 4;
	return true;
end

turtle.turnLeft = function()
	oldTurtle.turnLeft();
	if state.face == 0 then
		state.face = 3;
	else
		state.face = state.face - 1;
	end
	return true;
end

turtle.face = function(pFace)
	assert(pFace >= 0 and pFace <= 3, "Invalid direction " .. pFace);
	
	while (pFace > state.face) do turtle.turnRight(); end
	while (pFace < state.face) do turtle.turnLeft(); end
end

turtle.goto = function(pX, pY, pZ)
	assert(type(pX) == "number" and type(pY) == "number" and type(pZ) == "number", "Goto location must be given as 3 numbers");
	
	-- Correct x position
	if state.x > pX then
		turtle.face(SOUTH);
	elseif state.x < pX then
		turtle.face(NORTH);
	end	
	
	while state.x ~= pX do turtle.forward(); end
	
	-- Correcy z position
	if state.z > pZ then
		turtle.face(WEST);
	elseif state.z < pZ then
		turtle.face(EAST);
	end
	while state.z ~= pZ do turtle.forward(); end

	-- Correct y position
	while state.y > pY do turtle.down(); end
	while state.y < pY do turtle.up(); end
end

turtle.goHome = function()
	turtle.goto(state.home.x, state.home.y, state.home.z);
	turtle.face(state.home.face);
end

turtle.clearSlot = function(pSlot)
	turtle.select(pSlot);
	turtle.refuel(true);
	turtle.drop();
end

--[[
	Util
--]]
function clearInventory()
	for i = 1, 16 do
		turtle.select(i);
		turtle.drop();
	end
end

-- Remove any unwanted items from slot pStartIdx onward
function removeUnwanted(pStartIdx)
	assert(type(pStartIdx) == "number" and pStartIdx >= 1 and pStartIdx <= 16, "Invalid start idx " .. pStartIdx);

	for i = pStartIdx, 16 do
		turtle.select(i);
		turtle.refuel(true, 64);
		turtle.drop();
	end
end

--[[
	State machine
--]]
state = {
	job = findFirstTree,
	prevJob = nil,
	
	x = 0,
	y = 0,
	z = 0,
	face = 0,
	
	home = {
		x = 0,
		y = 0,
		z = 0,
		face = 0
	},
	
	fuelSlots = { [1] = true }
};

---------------------
-- Start
---------------------
print("Running Prey v" .. VER);

while state.job ~= nil do
	print("Job " .. tostring(state.job));
	state.job();
end

print("Done");
