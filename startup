--[[
    Vars
--]]
VER = 0.4;
NORTH, EAST, SOUTH, WEST = 0, 1, 2, 3;

LOG, DIRT, SAPLING, COBBLE, COAL = 1, 2, 3, 4, 5;

----------------------------------------------------------------------
-- Tasks
----------------------------------------------------------------------

--[[
	First Task:
		find first adjacent tree
--]]
function findFirstTree()
    turtle.removeUnwanted(LOG);
    turtle.select(LOG);
    
    while true do
        -- Get first wood
        if turtle.detect() then
            turtle.dig();
                
            -- Check is wood
            if turtle.refuel() then
                turtle.forward();
                setHomeToHere();
                
                -- Get second wood
            	turtle.up();
            	
            	-- Get rest of the wood
            	local gotEverything = cutTree(1,2);
            	if not gotEverything then
            		print(" - This tree is too big!");
            		exit();
            	end
            	
            	-- Refuel with sticks
                turtle.placeDown(); -- Save wood
            	turtle.craft();     -- Planks
            	turtle.transferTo(5, turtle.getItemCount(1) / 2);
            	turtle.craft();     -- Sticks
            	turtle.refuel(true, 64);
            	turtle.digDown();   -- Recover wood
            	
            	-- Next job
            	turtle.setJob(findMoreTrees);
            	break;
            else
            	turtle.drop();
            end
		else
			turtle.turnLeft();
		end
	end
end

--[[
    Second Task:
		find more near by trees
--]]
function findMoreTrees()
	turtle.goto(state.home.x, state.home.y + 2, state.home.z);
	
	local oldCount = turtle.getItemCount(1);
	
	-- loop
	for sideLng = 1, 10 do
		for corners = 0, 1 do
			for xz = 1, sideLng do
				turtle.select(1);
				turtle.forward();
				
				if turtle.getItemCount(1) > oldCount then
					cutTree(1, 2);
        			oldCount = turtle.getItemCount(1);
				elseif turtle.getItemCount(2) > 0 then                
        			turtle.select(2);
					-- Check is an unknown tree, if is cut it down using it all as fuel
					if (turtle.compareUp() or turtle.compareDown()) and turtle.refuel(true) then
					    cutTree(2, 3);
					end
					
        			turtle.clearSlot(2);
				end
			end
			turtle.turnRight();
		end
	end
	
    turtle.goHome();
    
	-- Refuel with sticks
    turtle.select(1); -- Save a log
    turtle.digUp();
    turtle.placeUp();
	turtle.craft();   -- Planks
	turtle.transferTo(5, turtle.getItemCount(1) / 2);
	turtle.craft();   -- Sticks
	turtle.refuel(true, 64);
    turtle.digUp();   -- Recover log
    
	turtle.setJob(findDirt);
end

--[[
    Third Task:
        find dirt
--]]
function findDirt()
    turtle.goHome();
    turtle.removeUnwanted(DIRT);
    
    turtle.select(DIRT);    
    turtle.digDown();
    
    turtle.setJob(findSaplings);
end

--[[
	Fourth Task:
		collect sapplings from first tree
--]]
function findSaplings()
    turtle.goto(state.home.x + NORTH, state.home.y, state.home.z);
    turtle.face(NORTH);
    
    turtle.removeUnwanted(SAPLING);

    local found = false;
    for side=1, 4 do
        for face=1, 4 do
            turtle.turnRight();
            
            -- If picked up something and hasn't found sapling
            if turtle.suck() and not found then 
                -- Make check area
                turtle.up();
                turtle.select(DIRT);
                turtle.placeDown();
                turtle.up();
                if turtle.detectUp() then turtle.digUp(); end
                
                turtle.select(SAPLING);
                if not turtle.placeUp() and turtle.placeDown() then
                	turtle.breakDown();
                    found = true;
                end
                
                turtle.down();
                turtle.select(DIRT);
                turtle.down();
            end
        end
        turtle.turnRight();
        turtle.forward();
        
        -- On all but first side go forward twice
        if side ~= 1 then 
            turtle.forward();
        end
        
        turtle.select(SAPLING);
        if not found then
        	-- Keep sapling slot clean without dropping
        	turtle.transfterTo(SAPLING + 2);
        end
    end
    
    turtle.setJob(findCobblestone);
end

--[[
	Fourth Task:
		find cobblestone
--]]
function findCobblestone()
    turtle.goHome();
    turtle.removeUnwanted(COBBLE);
    
    turtle.select(1);
    
    digToBedrock();
    turtle.goto(state.x, state.y + 9, state.z);
    
    -- Hit bottom, save height
    state.home.y = -state.y;
    state.y = 0;
    
    -- Dig to top
    turtle.forward();
    turtle.goto(state.x, state.home.y, state.z);
    
    -- Get any saplings that may have been there
    turtle.suckUp();
    
    -- Break surface if needed
    while turtle.detectUp() do turtle.up(); end
    
    -- Cobble must be one of first new blocks broken
    local highSlot, highSlotCount = 4, turtle.getItemCount(highSlot);
    for slot = 5, 10 do
        if turtle.getItemCount(slot) > highSlotCount then
            highSlot = slot;
        end
    end
    
    -- Move cobblestone if needed
    if highSlot ~= 4 then
        turtle.freeSlot(4, 16);
        turtle.freeSlot(highSlot, 4);
    end
    
    turtle.setJob(findCoal);
end

--[[
    Fifth Task:
        using items from find cobblestone determine which is coal
--]]
function findCoal()    
    -- Clear a space for placing
    turtle.digUp();
    
    for i=5, 16 do
        turtle.select(i);
        
        -- If can be placed not coal
        if turtle.placeUp() then
            turtle.digUp();
        -- If can't be placed and can refuel is coal
        elseif turtle.refuel(true) then
            if i ~= 5 then
            	turtle.freeSlot(5, 12);
            	turtle.transferTo(5);
            end
            break;
        end
    end
    
    -- Refuel with all but 1 coal
    turtle.select(5);
    turtle.refuel(true, turtle.getItemCount(5) - 1);

    turtle.setJob(buildBase);
end

--[[
    Task:
        build a base
--]]
function buildBase()
    -- Finalize home
    state.home.y = state.home.y + 11;
    turtle.goto(state.home.x, state.home.y - 1, state.home.z);
    
    turtle.select(4);
    turtle.face(NORTH);
    
    

    turtle.setJob(findIron);
end

--[[
    Task:
        go underground and mine a section looking for iron
--]]
function findIron()
    turtle.select(1);
    turtle.forward();
    
    -- Ore commong from (30-40)
    turtle.goto(state.x, 35, state.z);
    
    turtle.setJob(nil);
end

--[[
	New Turtle Util
--]]
oldTurtle = {
	turnRight = turtle.turnRight, turnLeft = turtle.turnLeft,
	forward = turtle.forward, back = turtle.back,
	up = turtle.up, down = turtle.down,
	refuel = turtle.refuel
};

turtle.refuel = function(pForce, pAmount)	
	if pForce or turtle.getFuelLevel() < 1 then
		if pAmount == nil then pAmount = 1; end
	
		if oldTurtle.refuel(pAmount) then
		    print(" - New fuel level " .. turtle.getFuelLevel());
		    return true;
        else
            return false;
        end
	else
		return true;
	end
end

-- Slow, use sparingly
turtle.back = function()
	turtle.turnRight();
	turtle.turnRight();
	if turtle.forward() then
		turtle.turnLeft();
		turtle.turnLeft();
	
		return true;
	else
		return false;
	end
end

turtle.forward = function()
	turtle.refuel();

	while not oldTurtle.forward() do
		-- Try to mine, if can't mine hit something unmineable (bedrock)
		if turtle.detect() and not turtle.dig() then return false; end
	
		while turtle.attack() do end
	end
	
	if state.face == NORTH then state.x = state.x + 1;
	elseif state.face == SOUTH then state.x = state.x - 1;
	elseif state.face == EAST then state.z = state.z + 1;
	elseif state.face == WEST then state.z = state.z - 1;
	else error("Turtle invalid face " .. state.face);
	end
	
	return true;
end
	
turtle.up = function()
	turtle.refuel();

	while not oldTurtle.up() do
		-- Try to mine, if can't mine hit something unmineable (bedrock)
		if turtle.detectUp() and not turtle.digUp() then return false; end
		
		while turtle.attackUp() do end
	end
	
	state.y = state.y + 1;
	return true;
end

turtle.down = function()
	turtle.refuel();

	while not oldTurtle.down() do
		-- Try to mine, if can't mine hit something unmineable (bedrock)
		if turtle.detectDown() and not turtle.digDown() then return false; end
		
		while turtle.attackDown() do end
	end

	state.y = state.y - 1;
	return true;
end

turtle.turnRight = function()
	oldTurtle.turnRight();
	state.face = (state.face + 1) % 4;
	return true;
end

turtle.turnLeft = function()
	oldTurtle.turnLeft();
	if state.face == 0 then
		state.face = 3;
	else
		state.face = state.face - 1;
	end
	return true;
end

--[[
	Turtle Util
--]]
turtle.freeSlot = function(pToFreeSlot, pToStoreSlot)
    turtle.select(pToFreeSlot);
    turtle.transferTo(pToStoreSlot);
end

turtle.face = function(pFace)
	assert(pFace >= 0 and pFace <= 3, "Invalid direction " .. pFace);
	
	while (pFace > state.face) do turtle.turnRight(); end
	while (pFace < state.face) do turtle.turnLeft(); end
end

turtle.goto = function(pX, pY, pZ)
	assert(type(pX) == "number" and type(pY) == "number" and type(pZ) == "number", "Goto location must be given as 3 numbers");
	
	-- Correct x position
	if state.x > pX then
		turtle.face(SOUTH);
	elseif state.x < pX then
		turtle.face(NORTH);
	end	
	
	while state.x ~= pX do turtle.forward(); end
	
	-- Correcy z position
	if state.z > pZ then
		turtle.face(WEST);
	elseif state.z < pZ then
		turtle.face(EAST);
	end
	while state.z ~= pZ do turtle.forward(); end

	-- Correct y position
	while state.y > pY do turtle.down(); end
	while state.y < pY do turtle.up(); end
end

turtle.goHome = function()
	turtle.goto(state.home.x, state.home.y, state.home.z);
	turtle.face(state.home.face);
end

turtle.clearSlot = function(pSlot)
	turtle.select(pSlot);
	turtle.refuel(true);
	turtle.drop();
end

turtle.clearInventory = function()
	for i = 1, 16 do
		turtle.select(i);
		turtle.drop();
	end
end

-- Remove any unwanted items from slot pStartIdx onward
turtle.removeUnwanted = function(pStartIdx)
	assert(type(pStartIdx) == "number" and pStartIdx >= 1 and pStartIdx <= 16, "Invalid start idx " .. pStartIdx);

	for i = pStartIdx, 16 do
		turtle.select(i);
		turtle.refuel(true, 64);
		turtle.drop();
	end
end

turtle.setJob = function(pJob)
	assert(pJob == nil or type(pJob) == "function");
	
	state.prevJob = state.job;
	state.job = pJob;
end

----------------------------------------------------------------------
-- Util
----------------------------------------------------------------------

--[[
    Common Functions
--]]

function digToBedrock()
    while not turtle.detectDown() or turtle.digDown() do
        turtle.down();
    end
end

-- Cut down a tree and remove excess in overflow slot
-- Return true if got everything
function cutTree(pTargSlot, pOverflow)
	assert(type(pOverflow) == "number" and type(pTargSlot) == "number", "Slots must be numbers");

    print(" - Cut tree at (" .. state.x .. "," .. state.z .. ")");

	local startY, startFace = state.y, state.face;
	
	turtle.select(pTargSlot);
	
	-- Handle doesn't have log
	if turtle.detectUp() then
		if turtle.getItemCount(pTargSlot <= 0)  then
			turtle.up();
		end
		
		while turtle.compareUp() do turtle.up(); end
		
		turtle.goto(state.x, startY, state.z);
	end
	
	-- Handle doesn't have log and none were above
	if turtle.detectDown() and turtle.getItemCount(pTargSlot) <= 0 then
		turtle.down();
	end
	
	local gotEverything = true;
	while state.y > startY or turtle.compareDown() do
		-- Confirm there are no other logs
		if gotEverything then
			for i=1, 4 do
				if turtle.compare() then
					gotEverything = false;
					break;
				end
				
				-- 270 degree not 360, resets face below
				if 1 ~= 4 then turtle.turnRight(); end
			end
		end
	
		turtle.down(); 
	end
	
	turtle.face(startFace);
	turtle.clearSlot(pOverflow);
	
	return gotEverything;
end

function setHomeToHere()
    state.home.x = state.x;
    state.home.y = state.y;
    state.home.z = state.z;
end

--[[
	State machine
--]]
state = {
	job = findFirstTree,
	prevJob = nil,
	
	x = 0,
	y = 0,
	z = 0,
	face = 0,
	
	home = {
		x = 0,
		y = 0,
		z = 0,
		face = 0
	}
};

---------------------
-- Start
---------------------
print("Running Prey v" .. VER);

while state.job ~= nil do
	print("* New Job " .. tostring(state.job));
	state.job();
end

print("Done");
