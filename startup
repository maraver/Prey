--[[
	Vars
		Slot 1 = Logs
		Slot 2 = Dirt
--]]
VER = 0.2;
NORTH, EAST, SOUTH, WEST = 0, 1, 2, 3;

--[[
	First task:
		find first adjacent tree
--]]
function findFirstTree()
	clearInventory();
	turtle.select(1);
	while true do
		-- Get first wood
		if turtle.detect() then
			turtle.dig();
			
			-- Check is wood
			if turtle.refuel() then
				-- Get second wood
				turtle.forward();
				turtle.up();
				
				-- Get rest of the wood
				while turtle.compareUp() do turtle.up(); end
				
				-- Save 1 wood
				turtle.placeDown();
				
				-- Refuel with sticks
				turtle.craft();
				turtle.transferTo(5, turtle.getItemCount(1) / 2);
				turtle.craft();
				turtle.refuel(true, 64);
				
				-- Get back 1 wood
				turtle.digDown();
				
				-- Goto start hight but here
				turtle.goto(state.x, 0, state.z);
				
				-- Get dirt
				turtle.select(2);
				turtle.digDown();
				
				-- Move home location
				state.home.x = state.x;
				state.home.y = 2;
				state.home.z = state.z;
				
				-- Next job
				turtle.setJob(findMoreTrees);
				break;
			else
				turtle.drop();
			end
		else
			turtle.turnLeft();
		end
	end
end

--[[
	Second task:
		find more near by trees
--]]
function findMoreTrees()
	turtle.goHome();
	
	removeUnwanted(3);
	turtle.select(1);
	
	local oldSlots = { [1] = turtle.getItemCount(1), [2] = turtle.getItemCount(2) };
	
	-- loop
	for sideLng = 1, 10 do
		for corners = 0, 1 do
			for xz = 1, sideLng do
				turtle.forward();
				
				if turtle.getItemCount(1) > oldSlots[1] then
					oldSlots[1] = turtle.getItemCount(1);
					cutTree(1, 3);
				elseif turtle.getItemCount(2) > oldSlots[2] then
					oldSlots[2] = turtle.getItemCount(2);
					if (state.y < state.home.y + 4) then 
						turtle.up();
					end
				elseif turtle.getItemCount(3) > 0 then
					-- Check is an unknown tree, if is cut it down using it all as fuel
					turtle.select(3);
					if turtle.compareUp() or turtle.compareDown() and turtle.refuel(true) then
						cutTree(3, 4);
					-- Only avoid if not too high already
					elseif (state.y < state.home.y + 4) then 
						turtle.up();
					end
					
					turtle.clearSlot(3);
					turtle.select(1);
				end
			end
			turtle.turnRight();
		end
	end
	
	removeUnwanted(3);
	
	turtle.setJob(findSaplings);
end

--[[
	Third Job
		collect sapplings from first tree
--]]
function findSaplings()
	turtle.goHome();
end

--[[
	Common Functions
--]]

-- Cut down a tree and remove excess in overflow slot
function cutTree(pTargSlot, pOverflow)
	assert(type(pOverflow) == "number" and type(pTargSlot) == "number", "Slots must be numbers");

	local startY = state.y;
	
	turtle.select(pTargSlot);
	while turtle.compareUp() do turtle.up(); end
	
	turtle.goto(state.x, startY, state.z);
	
	while turtle.compareDown() do turtle.down(); end
	
	turtle.goto(state.x, startY, state.z);
	
	turtle.clearSlot(pOverflow);
end

--[[
	New Turtle Util
--]]
oldTurtle = {
	turnRight = turtle.turnRight, turnLeft = turtle.turnLeft,
	forward = turtle.forward, back = turtle.back,
	up = turtle.up, down = turtle.down,
	refuel = turtle.refuel
};

turtle.setJob = function(pJob)
	assert(pJob == nil or type(pJob) == "function");
	
	state.prevJob = state.job;
	state.job = pJob;
end

turtle.refuel = function(pForce, pAmount)	
	if pForce or turtle.getFuelLevel() < 1 then
		if pAmount == nil then pAmount = 64; end
	
		return oldTurtle.refuel(pAmount);
	else
		return true;
	end
end

-- Slow, use sparingly
turtle.back = function()
	turtle.turnRight();
	turtle.turnRight();
	if turtle.forward() then
		turtle.turnLeft();
		turtle.turnLeft();
	
		return true;
	else
		return false;
	end
end

turtle.forward = function()
	turtle.refuel();

	while not oldTurtle.forward() do
		-- Try to mine, if can't mine hit something unmineable (bedrock)
		if turtle.detect() and not turtle.dig() then return false; end
	
		while turtle.attack() do end
	end
	
	if state.face == NORTH then state.x = state.x + 1;
	elseif state.face == SOUTH then state.x = state.x - 1;
	elseif state.face == EAST then state.z = state.z + 1;
	elseif state.face == WEST then state.z = state.z - 1;
	else error("Turtle invalid face " .. state.face);
	end
	
	return true;
end
	
turtle.up = function()
	turtle.refuel();

	while not oldTurtle.up() do
		-- Try to mine, if can't mine hit something unmineable (bedrock)
		if turtle.detectUp() and not turtle.digUp() then return false; end
		
		while turtle.attackUp() do end
	end
	
	state.y = state.y + 1;
	return true;
end

turtle.down = function()
	turtle.refuel();

	while not oldTurtle.down() do
		-- Try to mine, if can't mine hit something unmineable (bedrock)
		if turtle.detectDown() and not turtle.digDown() then return false; end
		
		while turtle.attackDown() do end
	end

	state.y = state.y - 1;
	return true;
end

turtle.turnRight = function()
	oldTurtle.turnRight();
	state.face = (state.face + 1) % 4;
	return true;
end

turtle.turnLeft = function()
	oldTurtle.turnLeft();
	if state.face == 0 then
		state.face = 3;
	else
		state.face = state.face - 1;
	end
	return true;
end

turtle.face = function(pFace)
	assert(pFace >= 0 and pFace <= 3, "Invalid direction " .. pFace);
	
	while (pFace > state.face) do turtle.turnRight(); end
	while (pFace < state.face) do turtle.turnLeft(); end
end

turtle.goto = function(pX, pY, pZ)
	assert(type(pX) == "number" and type(pY) == "number" and type(pZ) == "number", "Goto location must be given as 3 numbers");
	
	-- Correct x position
	if state.x > pX then
		turtle.face(SOUTH);
	elseif state.x < pX then
		turtle.face(NORTH);
	end	
	
	while state.x ~= pX do turtle.forward(); end
	
	-- Correcy z position
	if state.z > pZ then
		turtle.face(WEST);
	elseif state.z < pZ then
		turtle.face(EAST);
	end
	while state.z ~= pZ do turtle.forward(); end

	-- Correct y position
	while state.y > pY do turtle.down(); end
	while state.y < pY do turtle.up(); end
end

turtle.goHome = function()
	turtle.goto(state.home.x, state.home.y, state.home.z);
	turtle.face(state.home.face);
end

turtle.clearSlot = function(pSlot)
	turtle.select(pSlot);
	turtle.refuel(true);
	turtle.drop();
end

--[[
	Util
--]]
function clearInventory()
	for i = 1, 16 do
		turtle.select(i);
		turtle.drop();
	end
end

-- Remove any unwanted items from slot pStartIdx onward
function removeUnwanted(pStartIdx)
	assert(type(pStartIdx) == "number" and pStartIdx >= 1 and pStartIdx <= 16, "Invalid start idx " .. pStartIdx);

	for i = pStartIdx, 16 do
		turtle.select(i);
		turtle.refuel(true, 64);
		turtle.drop();
	end
end

--[[
	State machine
--]]

state = {
	job = findFirstTree,
	prevJob = nil,
	
	x = 0,
	y = 0,
	z = 0,
	face = 0,
	
	home = {
		x = 0,
		y = 0,
		z = 0,
		face = 0
	},
	
	fuelSlots = { [1] = true }
};

---------------------
-- Start
---------------------
print("Running Prey v" .. VER);

while state.job ~= nil do
	state.job();
end

print("Done");