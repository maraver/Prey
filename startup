--[[
    Vars
--]]
VER = 0.5;
NORTH, EAST, SOUTH, WEST = 0, 1, 2, 3;

-- Change with caution
LOG, DIRT, SAPLING, COBBLE, COAL = 1, 2, 3, 4, 5;

----------------------------------------------------------------------
-- Tasks
----------------------------------------------------------------------
--[[
	First Task:
		find first adjacent tree
--]]
function findFirstTree()
    turtle.removeUnwanted(LOG);
    turtle.select(LOG);
    
    while true do
        -- Get first wood
        if turtle.detect() then
            turtle.dig();
                
            -- Check is wood
            if turtle.refuel() then
                turtle.forward();
                setHomeToHere();
                
                -- Get second wood
            	turtle.up();
            	
            	-- Get rest of the wood
            	local gotEverything = cutTree(1, 2, false);
            	if not gotEverything then
            		print(" - This tree is too big!");
            		exit();
            	end
            	
            	-- Refuel with sticks
                turtle.placeUp(); -- Save wood
            	turtle.craft();     -- Planks
            	turtle.transferTo(5, turtle.getItemCount(1) / 2);
            	turtle.craft();     -- Sticks
            	turtle.refuel(true, 64);
            	turtle.digUp();   -- Recover wood
				
            	break;
            else
            	turtle.drop();
            end
		else
			turtle.turnLeft();
		end
	end
end

--[[
    Second Task:
		find more near by trees
--]]
function findMoreTrees()
	turtle.goto(state.home.x, state.home.y + 2, state.home.z);
	
	local oldCount = turtle.getItemCount(1);
	
	-- loop
	for sideLng = 1, 10 do
		for corners = 0, 1 do
			for xz = 1, sideLng do
				turtle.select(LOG);
				
				if turtle.dig() then
					turtle.forward();
					
					if turtle.getItemCount(1) > oldCount or turtle.compareDown() then
						cutTree(1, 2);
						oldCount = turtle.getItemCount(1);
					elseif turtle.getItemCount(2) > 0 then                
						turtle.select(2);
						-- Check is an unknown tree, if is cut it down using it all as fuel
						if (turtle.compareUp() or turtle.compareDown()) and turtle.refuel(true) then
							cutTree(2, 3);
						elseif state.y < state.home.y + 5 and turtle.dig() and turtle.place() then
							turtle.up();
						end
						
						turtle.clearSlot(2);
					else
						-- Dug with no result, leaves. Check for tree
						local startFace = state.face;
						
						for i=1, 3 do
							-- If in middle of a side don't need to check directly infront
							-- Will get that next step
							if xz ~= sideLng then turtle.turnRight(); end
						
							if turtle.compare() then
								local oldX, oldZ = state.x, state.z;
								turtle.forward();
								
								cutTree(1,2);
								oldCount = turtle.getItemCount(1);
								
								turtle.goto(oldX, state.y, oldZ);
								break;
							else
								turtle.turnRight();
							end
						end
						
						turtle.face(startFace);
					end
				else
					-- Always go forward, just don't need to do any checks
					turtle.forward();
				end
			end
			turtle.turnRight();
		end
	end
	
    turtle.goHome();
	turtle.removeUnwanted(2);
    
	-- Refuel with sticks
    turtle.select(LOG); -- Save a log
    turtle.digUp();
    turtle.placeUp();
	turtle.craft();   -- Planks
	turtle.transferTo(5, turtle.getItemCount(1) / 2);
	turtle.craft();   -- Sticks
	turtle.refuel(true, 64);
    turtle.digUp();   -- Recover log
end

--[[
    Third Task:
        find dirt
--]]
function findDirt()
    turtle.goHome();
    turtle.removeUnwanted(DIRT);
    turtle.select(DIRT);    
	
    turtle.digDown();
end

--[[
	Fourth Task:
		collect sapplings from first tree
--]]
function findSaplings()
	-- Go 2 north and 2 west
    turtle.goto(state.home.x + 2, state.home.y, state.home.z - 2);
    turtle.face(EAST);
    
    turtle.removeUnwanted(SAPLING);
	turtle.select(SAPLING);
	
    local found = false;
    for i=1, 14 do -- can skip last 2
		turtle.forward();
        for face=1, 4 do
            turtle.turnRight();
            
            -- If picked up something and hasn't found sapling
            if (turtle.suck() or turtle.suckDown()) and not found then 
                -- Make check area
                turtle.up();
                turtle.select(DIRT);
                turtle.placeDown();
                turtle.up();
                if turtle.detectUp() then turtle.digUp(); end
                
                turtle.select(SAPLING);
                if not turtle.placeUp() and turtle.placeDown() then
                	turtle.digDown();
                    found = true;
                end
                
                turtle.down();
                turtle.select(DIRT);
                turtle.down();
            end
        end
       
		if i % 4 == 0 then
			turtle.turnRight();
		end
        
        turtle.select(SAPLING);
        if not found then
        	-- Keep sapling slot clean without dropping
        	turtle.transferTo(SAPLING + 2);
        end
    end

	-- Check for last sapling at home
	turtle.select(SAPLING)
	turtle.goto(state.home.x, state.home.y + 1, state.home.z);
	turtle.suckDown();
	if not found then
		-- Keep sapling slot clean without dropping
		turtle.transferTo(SAPLING + 2);
	end
end

--[[
	Fourth Task:
		find cobblestone
--]]
function findCobblestone()
    turtle.goHome();
    turtle.removeUnwanted(COBBLE);
    turtle.select(1);
    
    digToBedrock();
    turtle.goto(state.x, state.y + 6, state.z);
    
    -- Hit bottom, save height
    state.home.y = -state.y;
    state.y = 0;
    
    -- Dig to top
    turtle.forward();
    turtle.goto(state.x, state.home.y, state.z);
    
    -- Get any saplings that may have been there
    turtle.suckUp();
    
    -- Break surface if needed
    while turtle.detectUp() do turtle.up(); end
    
    -- Cobble must be one of first new blocks broken
    local highSlot, highSlotCount = 4, turtle.getItemCount(highSlot);
    for slot = 5, 10 do
        if turtle.getItemCount(slot) > highSlotCount then
            highSlot = slot;
        end
    end
    
    -- Move cobblestone if needed
    if highSlot ~= 4 then
        turtle.freeSlot(4, 16);
        turtle.freeSlot(highSlot, 4);
    end
end

--[[
    Fifth Task:
        using items from find cobblestone determine which is coal
--]]
function findCoal()    
    -- Clear a space for placing
    turtle.digUp();
    
    for i=5, 16 do
        turtle.select(i);
        
        -- If can be placed not coal
        if turtle.placeUp() then
            turtle.digUp();
        -- If can't be placed and can refuel is coal
        elseif turtle.refuel(true) then
            if i ~= 5 then
            	turtle.freeSlot(5, 12);
            	turtle.transferTo(5);
            end
            break;
        end
    end
    
    -- Refuel with all but 1 coal
    turtle.select(5);
    turtle.refuel(true, turtle.getItemCount(5) - 1);
end

--[[
    Task:
        build a base
--]]
function buildBase()
    -- Finalize home
    state.home.y = state.home.y + 11;
    turtle.goto(state.home.x, state.home.y - 1, state.home.z);
    
    turtle.select(4);
    turtle.face(NORTH);
end

--[[
    Task:
        go underground and mine a section looking for iron
--]]
function findIron()
    turtle.select(1);
    turtle.forward();
    
    -- Ore commong from (30-40)
    turtle.goto(state.x, 35, state.z);
end

--[[
	New Turtle Util
--]]
oldTurtle = {
	turnRight = turtle.turnRight, turnLeft = turtle.turnLeft,
	forward = turtle.forward, back = turtle.back,
	up = turtle.up, down = turtle.down,
	refuel = turtle.refuel
};

turtle.refuel = function(pForce, pAmount)	
	if pForce or turtle.getFuelLevel() < 1 then
		if pAmount == nil then pAmount = 1; end
	
		if oldTurtle.refuel(pAmount) then
		    print(" - New fuel level " .. turtle.getFuelLevel());
		    return true;
        else
            return false;
        end
	else
		return true;
	end
end

-- Slow, use sparingly
turtle.back = function()
	turtle.turnRight();
	turtle.turnRight();
	if turtle.forward() then
		turtle.turnLeft();
		turtle.turnLeft();
	
		return true;
	else
		return false;
	end
end

turtle.forward = function()
	turtle.refuel();

	while not oldTurtle.forward() do
		-- Try to mine, if can't mine hit something unmineable (bedrock)
		if turtle.detect() and not turtle.dig() then return false; end
	
		while turtle.attack() do end
	end
	
	if state.face == NORTH then state.x = state.x + 1;
	elseif state.face == SOUTH then state.x = state.x - 1;
	elseif state.face == EAST then state.z = state.z + 1;
	elseif state.face == WEST then state.z = state.z - 1;
	else error("Turtle invalid face " .. state.face);
	end
	
	saveState();
	return true;
end
	
turtle.up = function()
	turtle.refuel();

	while not oldTurtle.up() do
		-- Try to mine, if can't mine hit something unmineable (bedrock)
		if turtle.detectUp() and not turtle.digUp() then return false; end
		
		while turtle.attackUp() do end
	end
	
	state.y = state.y + 1;
	
	saveState();
	return true;
end

turtle.down = function()
	turtle.refuel();

	while not oldTurtle.down() do
		-- Try to mine, if can't mine hit something unmineable (bedrock)
		if turtle.detectDown() and not turtle.digDown() then return false; end
		
		while turtle.attackDown() do end
	end

	state.y = state.y - 1;
	
	saveState();
	return true;
end

turtle.turnRight = function()
	oldTurtle.turnRight();
	state.face = (state.face + 1) % 4;
	
	saveState();
	return true;
end

turtle.turnLeft = function()
	oldTurtle.turnLeft();
	if state.face == 0 then
		state.face = 3;
	else
		state.face = state.face - 1;
	end
	
	saveState();
	return true;
end

--[[
	Turtle Util
--]]
turtle.freeSlot = function(pToFreeSlot, pToStoreSlot)
    turtle.select(pToFreeSlot);
    turtle.transferTo(pToStoreSlot);
end

turtle.face = function(pFace)
	assert(pFace >= 0 and pFace <= 3, "Invalid direction " .. pFace);
	
	while (pFace > state.face) do turtle.turnRight(); end
	while (pFace < state.face) do turtle.turnLeft(); end
end

turtle.goto = function(pX, pY, pZ)
	assert(type(pX) == "number" and type(pY) == "number" and type(pZ) == "number", "Goto location must be given as 3 numbers");
	
	-- Correct x position
	if state.x > pX then
		turtle.face(SOUTH);
	elseif state.x < pX then
		turtle.face(NORTH);
	end	
	
	while state.x ~= pX do turtle.forward(); end
	
	-- Correcy z position
	if state.z > pZ then
		turtle.face(WEST);
	elseif state.z < pZ then
		turtle.face(EAST);
	end
	while state.z ~= pZ do turtle.forward(); end

	-- Correct y position
	while state.y > pY do turtle.down(); end
	while state.y < pY do turtle.up(); end
end

turtle.goHome = function()
	turtle.goto(state.home.x, state.home.y, state.home.z);
	turtle.face(state.home.face);
end

turtle.clearSlot = function(pSlot)
	turtle.select(pSlot);
	turtle.refuel(true);
	turtle.drop();
end

turtle.clearInventory = function()
	for i = 1, 16 do
		turtle.select(i);
		turtle.drop();
	end
end

-- Remove any unwanted items from slot pStartIdx onward
turtle.removeUnwanted = function(pStartIdx)
	assert(type(pStartIdx) == "number" and pStartIdx >= 1 and pStartIdx <= 16);

	print(" - Removing from " .. pStartIdx .. " onward");
	for i = pStartIdx, 16 do
		turtle.select(i);
		turtle.refuel(true, 64);
		turtle.drop();
	end
end

----------------------------------------------------------------------
-- Util
----------------------------------------------------------------------

--[[
    Common Functions
--]]

function saveState()
	fs.delete("prey");
	local file = io.open("prey", "w");
	
	file:write(state.x .. "\n");
	file:write(state.y .. "\n");
	file:write(state.z .. "\n");
	file:write(state.face .. "\n");
	file:write(state.home.x .. "\n");
	file:write(state.home.y .. "\n");
	file:write(state.home.z .. "\n");
	file:write(state.home.face .. "\n");
	file:write(state.task .. "\n");
	
	file:close();
end

function readState()
	if not fs.exists("prey") then return; end

	local file = io.open("prey");

	local i = 0;
	for line in file:lines() do
		line = tonumber(line);
		
		if i == 0 then state.x = line;
		elseif i == 1 then state.y = line;
		elseif i == 2 then state.z = line;
		elseif i == 3 then state.face = line;
		elseif i == 4 then state.home.x = line;
		elseif i == 5 then state.home.y = line;
		elseif i == 6 then state.home.z = line;
		elseif i == 7 then state.home.face = line;
		elseif i == 8 then state.task = line;
		else error("Prey state file overflow!");
		end
		
		i = i + 1;
	end
	
	file:close();
end

function digToBedrock()
    while not turtle.detectDown() or turtle.digDown() do
        turtle.down();
    end
end

-- Cut down a tree and remove excess in overflow slot
-- Return true if got everything
function cutTree(pTargSlot, pOverflow, pIgnoreBranches)
	-- Type check
	assert(type(pOverflow) == "number" and type(pTargSlot) == "number", "Slots must be numbers");
	if type(pIgnoreBranches) ~= "boolean" then pIgnoreBranches = true; end

	print(" - Cut tree at (" .. state.x .. "," .. state.z .. ")");

	local startY, startFace = state.y, state.face;
	
	turtle.select(pTargSlot);
	
	-- Handle doesn't have log
	if turtle.detectUp() then
		if turtle.getItemCount(pTargSlot) <= 0  then
			turtle.up();
		end
		
		while turtle.compareUp() do turtle.up(); end
		
		turtle.goto(state.x, startY, state.z);
	end
	
	-- Handle doesn't have log and none were above
	if turtle.detectDown() and turtle.getItemCount(pTargSlot) <= 0 then
		turtle.down();
	end
	
	local pGotEverything = true;
	while turtle.compareDown() do
		-- Confirm there are no other logs
		if pGotEverything and not pIgnoreBranches then
			for i=1, 4 do
				if turtle.compare() then
					pGotEverything = false;
					break;
				end
				
				-- 270 degree not 360, resets face below
				if 1 ~= 4 then turtle.turnRight(); end
			end
		end
	
		turtle.down(); 
	end
	
	turtle.goto(state.x, startY, state.z);
	
	turtle.face(startFace);
	turtle.clearSlot(pOverflow);
	turtle.select(pTargSlot);
	
	return pGotEverything;
end

function setHomeToHere()
    state.home.x = state.x;
    state.home.y = state.y;
    state.home.z = state.z;
end

function copyStartup()
	if fs.exists("disk/startup") then
		if fs.exists("startup") then
			print("Replace startup file? (y/n)");
			local _, input = os.pullEvent("key");
			if tostring(input) ~= "y" and tostring(input) ~= "Y" then
				print("Canceled");
				return;
			end
			
			fs.delete("startup");
		end

		fs.copy("disk/startup", "startup");
	end
end

--[[
	State machine
--]]
state = {
	task = 1,
	
	x = 0,
	y = 0,
	z = 0,
	face = 0,
	
	home = {
		x = 0,
		y = 0,
		z = 0,
		face = 0
	}
};

tasks = {
	findFirstTree, findMoreTrees, findDirt, findSaplings, findCobblestone, findCoal, buildBase, findIron
};

---------------------
-- Start
---------------------

print("Running Prey v" .. VER);

copyStartup();
readState();
while state.task ~= -1 and state.task <= table.getn(tasks) do
	print("* New task " .. tostring(state.task) .. "/" .. table.getn(tasks));
	(tasks[state.task])();
	
	state.task = state.task + 1;
	saveState();
end

print("Done");
